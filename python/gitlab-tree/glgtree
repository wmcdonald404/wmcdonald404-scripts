#!/usr/bin/env python
import sys
import argparse
import os
import json

import yaml
from gitlab import Gitlab
from anytree import RenderTree
from anytree.importer import JsonImporter


def read_cli_arguments(argv=None):
  parser = argparse.ArgumentParser(description="Build a tree of Gitlab groups and projects")
  group = parser.add_mutually_exclusive_group()
  group.add_argument("-d", "--dictionary", action="store_true", help="Output as Python dictionary")
  group.add_argument("-j", "--json", action="store_true", help="Output as JSON")
  group.add_argument("-t", "--tree", action="store_true", help="Output as tree (default)")
  parser.add_argument("-g", "--group", type=int, help="Gitlab group to base output from")

  return parser.parse_args(argv)

def read_token() -> str:
  # Check if GITLAB_TOKEN environment variable exists
  if 'GITLAB_TOKEN' in os.environ:
    return os.environ['GITLAB_TOKEN']
  
  # Check if PAT token exists in glab configuration file
  glab_config_path = os.path.expanduser("~/.config/glab-cli/config.yml")
  if os.path.exists(glab_config_path):
    with open(glab_config_path, 'r') as config_file:
      glab_config = yaml.safe_load(config_file)
      if 'gitlab_token' in glab_config:
        return glab_config['gitlab_token']
  
  # Prompt the user to enter a PAT token
  return input("Enter your GitLab PAT token: ")

def create_connection(gitlab_token: str):
  gl = Gitlab(private_token=gitlab_token)
  gl.auth()
  return gl

def read_projects(gitlab_connection) -> list:
  project_list = []
  for project in gitlab_connection.projects.list(get_all=True, visibility='private'):
    project_dict = {
      'id': project.id, 
      'name': project.name, 
      'parent_id': project.namespace['id'], 
      'object_kind':'project', 
      'object_icon':'ğŸ“—'
    }
    project_list.append(project_dict)
  return project_list

def read_groups(gitlab_connection) -> list:
  group_list = []
  for group in gitlab_connection.groups.list(get_all=True, visibility='private'):
    group_dict = {
      'id': group.id,
      'name': group.name,
      'parent_id': group.parent_id,
      'object_kind':'group', 
      'object_icon':'ğŸ“',
      'children': []
    }
    group_list.append(group_dict)
  return group_list

# merge projects and groups
def organise_items(projects: list, groups: list) -> dict:
  # Create a dictionary where each parent_id is a key and its value is a list of groups with that parent_id
  parent_groups = {}
  for group in groups:
    parent_id = group['parent_id']
    if parent_id is None:
      continue
    if parent_id not in parent_groups:
      parent_groups[parent_id] = []
    parent_groups[parent_id].append(group)
  # Assign children to their respective parent groups
  for group in groups:
    group['children'] = parent_groups.get(group['id'], [])
  # Move the projects to their parent groups
  for project in projects:
    parent_id = project['parent_id']
    # Find the parent group
    parent_group = next((group for group in groups if group['id'] == parent_id), None)
    if parent_group:
      parent_group['children'].append(project)
  for parent in groups:
    if parent['parent_id'] == None:
      parent_dict = parent
  return parent_dict

def read_child(tree: dict, id: int) -> dict:
  # Depth-first search
  def dfs(node):
    if node['id'] == id:
      return node
    if 'children' in node:
      for child in node['children']:
        result = dfs(child)
        if result:
          return result
    return None  
  return dfs(tree)

def print_tree(tree: dict):
  json_tree = json.dumps(tree)
  importer = JsonImporter()
  root = importer.import_(json_tree)
  for pre, fill, node in RenderTree(root):
    print("%s%s %s (%s)" % (pre, node.object_icon, node.name, node.id))

def main(argv):
  # Gather command line arguments
  args = read_cli_arguments(argv)

  # Read token and establish connection
  token = read_token()
  connection = create_connection(token)

  # Gather groups, projects and establish hierarchy
  projects = read_projects(connection)
  groups = read_groups(connection)
  tree = organise_items(projects, groups)

  if args.group:
    tree = read_child(tree, args.group)
  if args.dictionary:
    print(tree)
  elif args.json:
    print(json.dumps(tree))
  elif args.tree:
    print_tree(tree)
  else:
    print_tree(tree)

if __name__ == "__main__":
  main(sys.argv[1:])

# TOFIX:
# - performance (investigate graphql endpoint instead of REST? (https://stackoverflow.com/a/71313528))
#   note: gitlab_connection.projects.list(visibility='private', get_all=True)
#     ~500 projects takes 30 secs 
#     ~10 projects takes 1.1 secs
#     terminal output makes little difference (few ms.)
#   note: gitlab_connection.groups.list(get_all=True, visibility='private')
#     ~120 groups adds 10 secs
#     ~7 groups adds 0.4 sec
#   comparison: the recursive glgtree version takes 2m14 for the full 648 object group/project tree

# TODO:
# - optionally source GITLAB_GROUP from environment
# - decompose some of the main logic into separate functions
# - Add disk caching/refresh?

# 'ğŸ—€' (U+1F5C0)
# 'ğŸ“' (U+1F4C1)
# 'ğŸ“‚' (U+1F4C2)
# 'ğŸ•®' (U+1F56E)
# 'ğŸ“š' (U+1F4DA)
# 'ğŸ“–' (U+1F4D6)
# 'ğŸ“•' (U+1F4D5)
# 'ğŸ“˜' (U+1F4D8)
# 'ğŸ““' (U+1F4D3)
# 'ğŸ“™' (U+1F4D9)
# 'ğŸ“—' (U+1F4D7)
#
#   # default group
#   default_value = '86427305'  

  # print('======= projects ======= \n', projects, '\n')
  # print('======== groups ======== \n', groups, '\n')
  # print('==== organised list ==== \n', organised_items, '\n')
  # print('===== final dict ======= \n', final_dict, '\n')
  # print('===== final json ======= \n', final_json, '\n')
