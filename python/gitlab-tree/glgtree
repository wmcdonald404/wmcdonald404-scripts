#!/usr/bin/env python
import sys
import getopt
import os
import yaml
import json
from gitlab import Gitlab
from anytree.importer import JsonImporter
from anytree import RenderTree

def read_command_line_options(argv):
  # Default value
  default_value = '86427305'
  
  try:
    # Define the options and their corresponding arguments
    opts, args = getopt.getopt(argv, "hg:", ["gvalue="])
  except getopt.GetoptError:
    print('Usage: example.py -g <value>')
    sys.exit(2)
  
  # Parse the options and their arguments
  for opt, arg in opts:
    if opt == '-h':
      print('Usage: example.py -g <value>')
      sys.exit()
    elif opt in ("-g", "--gvalue"):
      default_value = arg
  
  # If no additional option is passed with -g, prompt the user
  if default_value == 'default_value':
    user_input = input(f"No additional value passed with -g. Default value is '{default_value}'. Press Enter to use default or provide a new value: ")
    if user_input:
      default_value = user_input
  
  return default_value

def read_token() -> str:
  # Check if GITLAB_TOKEN environment variable exists
  if 'GITLAB_TOKEN' in os.environ:
    return os.environ['GITLAB_TOKEN']
  
  # Check if PAT token exists in glab configuration file
  glab_config_path = os.path.expanduser("~/.config/glab-cli/config.yml")
  if os.path.exists(glab_config_path):
    with open(glab_config_path, 'r') as config_file:
      glab_config = yaml.safe_load(config_file)
      if 'gitlab_token' in glab_config:
        return glab_config['gitlab_token']
  
  # Prompt the user to enter a PAT token
  return input("Enter your GitLab PAT token: ")

def create_connection(gitlab_token: str):
  gl = Gitlab(private_token=gitlab_token)
  gl.auth()
  return gl

def read_projects(gitlab_connection) -> list:
  project_list = []
  for project in gitlab_connection.projects.list(get_all=True, visibility='private'):
    project_dict = {
      'id': project.id, 
      'name': project.name, 
      'parent_id': project.namespace['id'], 
      'object_kind':'project', 
      'object_icon':'📗'
    }
    project_list.append(project_dict)
  return project_list

def read_groups(gitlab_connection) -> list:
  group_list = []
  for group in gitlab_connection.groups.list(get_all=True, visibility='private'):
    group_dict = {
      'id': group.id,
      'name': group.name,
      'parent_id': group.parent_id,
      'object_kind':'group', 
      'object_icon':'📁',
      'children': []
    }
    group_list.append(group_dict)
  return group_list

# merge projects and groups
def organise_items(projects, groups):
  # Create a dictionary where each parent_id is a key and its value is a list of groups with that parent_id
  parent_groups = {}
  for group in groups:
    parent_id = group['parent_id']
    if parent_id is None:
      continue
    if parent_id not in parent_groups:
      parent_groups[parent_id] = []
    parent_groups[parent_id].append(group)
  # Assign children to their respective parent groups
  for group in groups:
    group['children'] = parent_groups.get(group['id'], [])
  # Move the projects to their parent groups
  for project in projects:
    parent_id = project['parent_id']
    # Find the parent group
    parent_group = next((group for group in groups if group['id'] == parent_id), None)
    if parent_group:
      parent_group['children'].append(project)
  return groups

def main(argv):
  start_group_id = read_command_line_options(argv)  
  token = read_token()
  connection = create_connection(token)
  projects = read_projects(connection)
  groups = read_groups(connection)
  organised_items = organise_items(projects, groups)
  for o in organised_items:
    if o['parent_id'] == None:
      final_dict = o
  final_json = json.dumps(final_dict)
  importer = JsonImporter()
  root = importer.import_(final_json)

  # print('======= projects ======= \n', projects, '\n')
  # print('======== groups ======== \n', groups, '\n')
  # print('==== organised list ==== \n', organised_items, '\n')
  # print('===== final dict ======= \n', final_dict, '\n')
  # print('===== final json ======= \n', final_json, '\n')

  for pre, fill, node in RenderTree(root):
    print("%s%s %s (%s)" % (pre, node.object_icon, node.name, node.id))
  
if __name__ == "__main__":
  main(sys.argv[1:])

# TOFIX:
# - starting tree from the main group, not the specified group (read_group_list error?)
# - performance (investigate graphql endpoint instead of REST? (https://stackoverflow.com/a/71313528))
#   note: gitlab_connection.projects.list(visibility='private', get_all=True)
#     ~500 projects takes 30 secs 
#     ~10 projects takes 1.1 secs
#     terminal output makes little difference (few ms.)
#   note: gitlab_connection.groups.list(get_all=True, visibility='private')
#     ~120 groups adds 10 secs
#     ~7 groups adds 0.4 sec
#   comparison: the recursive glgtree version takes 2m14 for the full 648 object group/project tree

# TODO:
# - optionally source GITLAB_GROUP from environment
# - CLI toggle for anytree, JSON output or bare Python dict output
# - decompose some of the main logic into separate functions

# '🗀' (U+1F5C0)
# '📁' (U+1F4C1)
# '📂' (U+1F4C2)
# '🕮' (U+1F56E)
# '📚' (U+1F4DA)
# '📖' (U+1F4D6)
# '📕' (U+1F4D5)
# '📘' (U+1F4D8)
# '📓' (U+1F4D3)
# '📙' (U+1F4D9)
# '📗' (U+1F4D7)
